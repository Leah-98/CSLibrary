# 一、操作系统的主要功能

操作系统的主要功能是对处理机、存储器、IO设备以及文件（数据和程序）进行有效的管理。

![image-20230310103240271](imgs\image-20230310103240271.png)

## ①**处理机**管理功能

进程控制、进程同步、进程通信、调度（作业调度、进程调度）。

## ②存储器管理功能

- 内存分配

  - 为每道程序分配内存空间，使它们“各得其所”

  - 提高存储器的利用率，尽量减少不可用的内存空间（碎片）

  - 允许正在运行的程序申请附加的内存空间，以适应程序和数据动态增长的需要

> OS在实现内存分配时，可采取静态和动态两种方式： 
>
> (1) **静态分配方式**：每个作业的内存空间是在作业装入 时确定的，在作业装入后的整个运行期间不允许该作业再申 请新的内存空间，也不允许作业在内存中“移动”。 
>
> (2) **动态分配方式**：每个作业所要求的基本内存空间虽 然也是在装入时确定的，但允许作业在运行过程中继续申请 新的附加内存空间，以适应程序和数据的动态增长，也允许 作业在内存中“移动”。

- 内存保护
  - 确保每道用户程序都仅在自己的内存空间内运行，彼此互不干扰。
  - 绝不允许用户程序访问操作系统的程序和数据，也不允许用户程序转移到非共享的其它用户程序中去进行。
- 地址映射
  - 在多道程序环境下，由于每道程序经编译和链接后所形成的可装入程序其地址都是从0开始的（逻辑地址），而存储在内存空间中的地址不可能都是从0开始的（物理地址）。地址映射功能，即能够将地址空间中的逻辑地址转换为内存空间中与之对应的物理地址。该功能应在硬件的支持下完成。

- 内存扩充
  - 内存扩充是借助于虚拟存储技术，从逻辑上扩充内存容量，使用户所感觉到 的内存容量比实际内存容量大得多，以便让更多的用户程序 能并发运行。为了能在逻辑上扩充内存，系统必须设置内存扩充机制 (包含少量的硬件)，用于实现下述各功能： (1) 请求调入功能。 (2) 置换功能。

## ③**设备**管理功能

缓冲管理、设备分配、设备处理

> 主要任务：
>
> (1) 完成用户进程提出的I/O请求，为用户进程分配所需的I/O设备，并完成指定的I/O操作。
>
> (2) 提高CPU和I/O设备的利用率，提高I/O速度，方便用户使用I/O设备。

## ④**文件**管理功能

- 文件存储空间的管理
- 目录管理
- 文件的读/写管理和保护

## ⑤操作系统与用户之间的接口

- 用户接口（联机用户接口、脱机用户接口、图形用户接口）
- 程序接口
  - 程序接口是为用户程序在执行中访问系统资源而设置的， 是用户程序取得操作系统服务的唯一途径。它是由一组系统 调用组成的，每一个系统调用都是一个能完成特定功能的子 程序。每当应用程序要求OS提供某种服务(功能)时，便调用 具有相应功能的系统调用(子程序)。早期的系统调用都是用 汇编语言提供的，只有在用汇编语言书写的程序中才能直接 使用系统调用。

## ⑥现代操作系统的新功能

- 系统安全：认证技术、密码技术、访问控制技术、反病毒技术
- 网络的功能和服务：网络通信、资源管理、应用互操作

- 支持多媒体：接纳控制功能、实时调度、多媒体文件的存储

# 二、进程控制

## 1.**进程控制块**（PCB ProcessControlBlock）

作用：使一个在多道程序环境下不能独立运行的程序(含数据)，成为一个能独立运行的基本单位，一个能与其它进程并发执行的进程。或者说，OS是根据PCB来对并发执行的进程进行控制和管理的。

信息：

- **进程标识符**：用于惟一地标识一个进程。一个进程通常有两种标识符：
  - **内部标识符**：在所有的操作系统中，都为每一个进程赋予一个惟一的数字标识符，它通常是一个进程的序号。 设置内部标识符主要是为了方便系统使用。
  - **外部标识符**：它由创建者提供，通常是由字母、数字组成，往往是由用户(进程)在访问该进程时使用。为了描述进程的家族关系， 还应设置父进程标识及子进程标识。 此外，还可设置用户标识，以指示拥有该进程的用户。
- **处理机状态信息**：主要是由处理机的各种寄存器中的内容组成的。
  - **通用寄存器**：又称为用户可视寄存器，它们是 用户程序可以访问的，用于暂存信息， 在大多数处理机中， 有 8~32 个通用寄存器，在RISC结构的计算机中可超过 100 个；
  - **指令计数器**：其中存放了要访问的下一条指令的地址；
  - **程序状态字PSW**：其中含有状态信息，如条件码、 执行方式、 中断屏蔽标志等； 
  - **用户栈指针**： 指每个用户进程都有一个或若干个与之相关的系统栈，用于存放过程和系统调用参数及调用地址。栈指针指向该栈的栈顶。
- **进程调度信息**：在PCB中还存放一些与进程调度和进程对换有关的信息，包括： 
  - **进程状态**：指明进程的当前状态， 作为进程调度和对换时的依据；
  - **进程优先级**：用于描述进程使用处理机的优先级别的一个整数， 优先级高的进程应优先获得处理机； 
  - **进程调度所需的其它信息**：它们与所采 用的进程调度算法有关，比如，进程已等待CPU的时间总 和、 进程已执行的时间总和等；
  - **事件**：是指进程由执行状态转变为阻塞状态所等待发生的事件，即阻塞原因
- **进程控制信息**：
  - **程序和数据的地址**： 是指进 程的程序和数据所在的内存或外存地(首)址，以便再调度到该进程执行时，能从PCB中找到其程序和数据；
  - **进程同步和通信机制**：指实现进程同步和进程通信时必需的机制， 如消息队列指针、信号量等，它们可能全部或部分地 放在PCB中； 
  - **资源清单**：是一张列出了除CPU以外的、 进程所需的全部资源及已经分配到该进程的资源的清单； 
  - **链接指针**： 它给出了本进程(PCB)所在队列中的下一个进程的PCB的首地址。

## 2.进程状态的转换

![image-20230313150443305](E:\personal\CSLibrary\01_计算机基础\操作系统原理\imgs\image-20230313150443305.png)

### ①进程创建

1. 引起创建进程的事件：用户登录、多页调度、提供服务、应用请求。

2. 进程的创建
   1. 申请空白PCB。 
   2. 为新进程分配资源。 
   3. 初始化进程控制块。
   4. 将新进程插入就绪队列，如果进程就绪队列能够接纳新进程， 便将新进程插入就绪队列。

### ②进程终止

1. 引起进程终止的事件

   - 正常结束：在任何计算机系统中，都应有一个用于表示进程已经 运行完成的指示。例如，在批处理系统中，通常在程序的 最后安排一条**Holt指令**或终止的系统调用。当程序运行到 Holt指令时，将产生一个中断，去通知OS本进程已经完成。 在分时系统中，用户可利用**Logs off**去表示进程运行完毕， 此时同样可产生一个中断，去通知OS进程已运行完毕。

   - 异常结束：在进程运行期间，由于出现某些错误和故障而迫使进程 终止。这类异常事件很多，常见的有：
     - 越界错误：这是指程序所访问的存储区，已越出该进程的区域；
     - 保护错：进 程试图去访问一个不允许访问的资源或文件，或者以不适当的方式进行访问，例如，进程试图去写一个只读文件； 
     - 非法指令：程序试图去执行一条不存在的指令。出现该错误的原因，可能是程序错误地转移到数据区，把数据当成了指令； 
     - 特权指令错：用户进程试图去执行一条只允许OS执行的指令；
     - 运行超时：进程的执行时间超过了指定的最大值；
     - 等待超时：进程等待某事件的时间， 超过了规定的最大值；
     - 算术运算错：进程试图去执行一个被禁止的运算，例如， 被0除；
     - I/O故障：这是指在I/O过程中发生了错误等。

   - 外界干预：外界干预并非指在本进程运行中出现了异常事件， 而是指进程应外界的请求而终止运行。这些干预有：
     - 操作员或操作系统干预。 由于某种原因，例如，发生了 死锁， 由操作员或操作系统终止该进程； 
     - 父进程请 求。 由于父进程具有终止自己的任何子孙进程的权利， 因而当父进程提出请求时，系统将终止该进程； 
     - 父进 程终止。 当父进程终止时，OS也将他的所有子孙进程终 止。

2. 进程的中止过程
   1. 根据被终止进程的标识符，从PCB集合中检索出该 进程的PCB，从中读出该进程的状态。
   2. 若被终止进程正处于执行状态，应立即终止该进程 的执行，并置调度标志为真，用于指示该进程被终止后应 重新进行调度。 
   3. 若该进程还有子孙进程，还应将其所有子孙进程予 以终止，以防他们成为不可控的进程。 
   4. 将被终止进程所拥有的全部资源，或者归还给其父 进程， 或者归还给系统。 
   5. 将被终止进程(它的PCB)从所在队列(或链表)中移出， 等待其他程序来搜集信息。

### ③进程的阻塞与唤醒

1. 引起进程阻塞和唤醒的事件：请求系统服务、启动某种操作、新数据尚未到达、无新工作可做。
2. 进程阻塞过程：正在执行的进程，当发现上述某事件时，由于无法继续 执行，于是进程便通过调用阻塞原语block把自己阻塞。可见， 进程的阻塞是进程自身的一种<u>主动行为</u>。进入block过程后， 由于此时该进程还处于执行状态，所以应先立即停止执行， 把进程控制块中的现行状态由“执行”改为阻塞，并将PCB插 入阻塞队列。如果系统中设置了因不同事件而阻塞的多个阻 塞队列，则应将本进程插入到具有相同事件的阻塞(等待)队列。 最后，转调度程序进行重新调度，将处理机分配给另一就绪 进程，并进行切换，亦即，保留被阻塞进程的处理机状态(在 PCB中)，再按新进程的PCB中的处理机状态设置CPU的环境。
3. 进程唤醒过程：当被阻塞进程所期待的事件出现时，如I/O完成或其所 期待的数据已经到达，则由有关进程(比如，用完并释放 了该I/O设备的进程)调用唤醒原语wakeup( )，将等待该事 件的进程唤醒。唤醒原语执行的过程是：首先把被阻塞的 进程从等待该事件的阻塞队列中移出，将其PCB中的现行 状态由阻塞改为就绪，然后再将该PCB插入到就绪队列中。

### ④进程的挂起与激活

1. 进程的挂起：当出现了引起进程挂起的事件时，比如，用户进程 请求将自己挂起，或父进程请求将自己的某个子进程挂 起， 系统将利用挂起原语suspend( )将指定进程或处于阻 塞状态的进程挂起。挂起原语的执行过程是：首先检查 被挂起进程的状态，若处于活动就绪状态，便将其改为 静止就绪；对于活动阻塞状态的进程，则将之改为静止 阻塞。 为了方便用户或父进程考查该进程的运行情况而 把该进程的PCB复制到某指定的内存区域。最后，若被 挂起的进程正在执行，则转向调度程序重新调度。
2. 进程的激活过程：当发生激活进程的事件时，例如，父进程或用户进程请 求激活指定进程，若该进程驻留在外存而内存中已有足够的 空间时，则可将在外存上处于静止就绪状态的进程换入内存。 这时，系统将利用激活原语active( )将指定进程激活。 激活 原语先将进程从外存调入内存，检查该进程的现行状态，若 是静止就绪，便将之改为活动就绪；若为静止阻塞便将之改 为活动阻塞。假如采用的是抢占调度策略，则每当有新进程 进入就绪队列时，应检查是否要进行重新调度，即由调度程 序将被激活进程与当前进程进行优先级的比较，如果被激活 进程的优先级更低，就不必重新调度；否则，立即剥夺当前 进程的运行，把处理机分配给刚被激活的进程。

## 3.进程同步

临界资源：一次仅允许一个进程使用的共享资源

AND同步机制：将进程在整个运行过程 中需要的所有资源，一次性全部地分配给进程，待进程使 用完后再一起释放。只要尚有一个资源未能分配给进程， 其它所有可能为之分配的资源，也不分配给他。亦即，对 若干个临界资源的分配，采取原子操作方式：要么全部分 配到进程，要么一个也不分配。 由死锁理论可知，这样就 可避免上述死锁情况的发生。

管程机制：

- 信号量的大量同步操作分散在各个进程中不便于管理，还有可能导致系统死锁。
- 管程即把所有进程堆某一种临界资源的同步操作都集中起来，构成一个秘书进程。凡要访问该临界资源的进程，都需先报告秘书，由秘书来实现诸进程对同一临界资源的互斥使用。
- 管程的构成：
  - 局部于管程的共享数据结构；
  - 对共享数据结构进行操作的一组函数；
  - 对局部于管程的数据设置初始值的语句。

