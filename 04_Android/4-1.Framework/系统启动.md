# Android系统启动的流程

![image-20231204170320731](D:\personal\CSLibrary\04_Android\imgs\image-20231204170320731.png)

Step1：启动电源及系统启动

当电源按下，引导芯片代码开始从预定义的地方（固化在ROM）开始执行。加载引导程序到RAM，然后执行。

Step2：引导程序

引导程序是在Android操作系统开始运行前的一个小程序。引导程序是运行的第一个程序，因此它是针对特定的主板与芯片的。设备制造商要么使用很受欢迎的引导程序比如redboot、uboot、qibootloader或者开发自己的引导程序，它不是Android操作系统的一部分。引导程序是OEM厂商或者运营商加锁和限制的地方。

引导程序分两个阶段执行：

第一个阶段，检测外部的RAM以及加载对第二阶段有用的程序；

第二个阶段，引导程序设置网络、内存等等。这些对于运行内核是必要的，为了达到特殊的目标，引导程序可以根据配置参数或者输入数据设置内核。

Android引导程序可以在\bootable\bootloader\legacy\usbloader找到。传统的加载器包含两个文件，需要在这里说明：

init.s初始化堆栈，清零BBS段，调用main.c的_main()函数；

main.c初始化硬件（闹钟、主板、键盘、控制台），创建Linux标签

Step3：内核

Android内核与桌面Linux内核的启动方式差不多。内核启动时，设置缓存、被保护存储器、计划列表，加载驱动。当内核完成系统设置，它首先在系统文件中寻找“init”文件，然后启动root进程或者系统的第一个进程

Step4：init进程

init进程时Linux系统中用户空间的第一个进程，进程号固定为1。Kernel启动后，在用户空间启动init进程，并调用init中的main() 方法执行init进程的职责。

Step5：启动Launcher App

# init进程分析

![image-20231205174832961](D:\personal\CSLibrary\04_Android\imgs\image-20231205174832961.png)

读图：

1. init进程启动zygote和servicemanager
2. zygote利用socket与system_server进行联系
3. system_server\servicemanager\app三者之间利用binder进行联系

init进程的操作：

1. 创建和挂载启动所需要的文件目录
2. 初始化和启动属性服务
3. 解析init.rc配置文件并启动Zygote进程

精炼源码分析（以后在更新的源码上再看一次）：

1. ueventd主要负责设备节点的创建、权限设定等一系列工作；watchdogd用于系统出问题时重启系统

2. 如果参数同时从命令行和DT传过来，DT的优先级总是大于命令行的

> 在 Android 中，"Device Tree"（设备树）通常是指 Android 操作系统的设备树机制。设备树是一种用于描述硬件设备和其连接关系的数据结构，它被广泛用于嵌入式系统中，包括 Android 设备。
>
> Android 设备树的主要目的是为了在 Linux 内核中动态描述和配置硬件设备。设备树通常以一种类似于 XML 的结构进行描述，其中包含了有关系统硬件、设备、中断、总线等信息的详细描述。
>
> 主要的 Android 设备树文件是 `dts`（设备树源）文件，它们编译成 `dtb`（设备树二进制）文件，然后由 Linux 内核加载并解释。设备树的使用允许 Android 操作系统在多种硬件平台上运行，而无需为每个平台定制和编译一个特定的内核。
>
> Android 设备树包括以下方面的信息：
>
> 1. **硬件组件：** 描述了处理器、内存、外设等硬件组件的信息。
> 2. **中断：** 描述了系统中各种中断的分配和连接。
> 3. **总线：** 描述了系统中使用的总线，如 I2C、SPI、PCI 等。
> 4. **设备：** 描述了连接到系统的各种设备，如传感器、摄像头、显示器等。
>
> 通过使用设备树，Android 能够更容易地适应各种硬件配置，使其更加灵活和可移植。

# init.rc解析

## 服务启动机制

1. system/core/init/init.c文件main函数中parse_config_file(init.rc)读取并解析init.rc文件内容。将service信息放置到system/core/init/init_parser.cpp的service_list中
2. system/core/init/init.c文件main函数继续执行restart_servie_if_needed(…) -> service_start(…) -> Execve(…)建立service进程；

为了让大伙看得更明白，上个图先《总体启动框架图》： ![img](D:\personal\CSLibrary\04_Android\imgs\22.png)

## init.rc 简介

目前Linux有很多通讯机制可以在用户空间和内核空间之间交互，例如设备驱动文件（位于/dev目录中）、内存文件（/proc、/sys目录等）。了解Linux的同学都应该知道Linux的重要特征之一就是一切都是以文件的形式存在的，例如，一个设备通常与一个或多个设备文件对应。这些与内核空间交互的文件都在用户空间，所以在Linux内核装载完，需要首先建立这些文件所在的目录。而完成这些工作的程序就是本文要介绍的init。Init是一个命令行程序。其主要工作之一就是建立这些与内核空间交互的文件所在的目录。当Linux内核加载完后，要做的第一件事就是调用init程序，也就是说，init是用户空间执行的第一个程序。

尽管init完成的工作不算很多，不过代码还是非常复杂的。***Init程序并不是由一个源代码文件组成的\***，而是由一组源代码文件的目标文件链接而成的。这些文件位于如下的目录。

需要明白的是，这些init.rc只是语法文件，并不是程序，真正的入口则是上面提到的system/core/init/init.c 因为init.c文件比较大，在文章的第二部分我会简要的通过main函数分析init启动流程；

init.rc有两个，分别位于：
./system/core/rootdir/init.rc
./bootable/recovery/etc/init.rc
从目录上大致可以猜测，这两个init.rc使用场景不一样，一个是刷机用到的，也就是进入recorvery模式，一个是正常启动用到的；我们这里重点分析的是上面那个，也是init.c关联的那个；

## init.rc语法结构解析

要了解init.rc是怎么解析的，我们需要先看看说明文档，说明文档在，当然也可以看下热心网友的中文对照版本；
init.rc位于/bootable/recovery/etc/init.rc

Android初始化语言包含了四种类型的声明：
Actions（行为）、Commands（命令）、Services（服务）和Options（选项）

所有这些都是以行为单位的，各种记号由空格来隔开。
C语言风格的反斜杠号可用于在记号间插入空格。
双引号也可用于防止字符串被空格分割成多个记号。
行末的反斜杠用于折行，注释行以井号（#）开头（允许以空格开头）。

**需要注意的是，这个只是一个语法文件，就像一个xml文件一样，没有执行顺序的，解析器通过读这个文件获取想要的数据，包括service，action等**

Actions和Services声明一个新的分组Section。所有的命令或选项都属于最近声明的分组。位于第一个分组之前的命令或选项将会被忽略。 Actions和Services有唯一的名字。如果有重名的情况，第二个申明的将会被作为错误忽略。

## Actions

**Actions（行为）是一系列命令的开始**

Actions代表一些Action.Action代表一组命令(Commands),Actions都有一个trigger（触发器）,该触发器决定了何时执行这个Action,即在什么情况下才能执行该Action中的定义命令.当一些条件满足触发器的条件时,该Action中定义的命令会被添加到要执行命令队列的尾部(如果这组命令已经在队列中,则不会再次添加).

队列中的每一个action都被依次提取出，而这个action中的每个command（命令）在一个Action从队列移除时,该Action定义的命令会依次被执行.

Action的格式如下:

| `1 2 3 4 5 ` | `on <trgger> [&& <trigger>]*   <command1>   <command2>   <command3>   ...` |
| ------------ | ------------------------------------------------------------ |
|              |                                                              |

on后面跟着一个触发器，当trigger被触发时，command1，command2，command3，会依次执行，直到下一个Action或下一个Service。

简单来说，Actions就是Android在启动时定义的一个启动脚本，当条件满足时，会执行该脚本，脚本里都是一些命令commands，不同的脚本用on来区分。

## Triggers（触发器）

trigger即我们上面所说的触发器,本质上是一个字符串,能够匹配某种包含该字符串的事件.
trigger又被细分为事件触发器(event trigger)和属性触发器(property trigger).
Triggers（触发器）是一个用于匹配特定事件类型的字符串，用于使Actions发生。

事件触发器可由”trigger”命令或初始化过程中通过QueueEventTrigger()触发,通常是一些事先定义的简单字符串, 例如:boot,late-init
属性触发器是当指定属性的变量值变成指定值时触发,其格式为property:=*

一个Action可以有多个属性触发器,但是最多有一个事件触发器.下面我们看两个例子:

| `1 ` | `on boot && property:a=b` |
| ---- | ------------------------- |
|      |                           |

该Action只有在boot事件发生时,并且属性a和b相等的情况下才会被触发.

| `1 ` | `on property:a=b && property:c=d` |
| ---- | --------------------------------- |
|      |                                   |

该Action会在以下三种情况被触发:

- 在启动时,如果属性a的值等于b并且属性c的值等于d
- 在属性c的值已经是d的情况下,属性a的值被更新为b
- 在属性a的值已经是b的情况下,属性c的值被更新为d

当前AIL中常用的有以下几种事件触发器:

| `1 2 3 4 5 6 7 8 9 ` | `类型                      说明 ------------------------------------------------- boot                    init.rc被装载后触发 device-added-<path>     指定设备被添加时触发 device-removed-<path>   指定设备被移除时触发 service-exited-<name>   在特定服务(service)退出时触发 early-init              初始化之前触发 late-init               初始化之后触发 init                    初始化时触发（在 /init.conf （启动配置文件）被装载之后）` |
| -------------------- | ------------------------------------------------------------ |
|                      |                                                              |

Init的触发是由init.c里的函数action_for_each_trigger来决定的（在main函数中被调用）。

## Services

Services（服务）是一个程序，以 service开头，由init进程启动，一般运行于另外一个init的子进程，所以启动service前需要判断对应的可执行文件是否存在。init生成的子进程，定义在rc文件，其中每一个service，在启动时会通过fork方式生成子进程。Services（服务）的形式如下：

| `1 2 3 4 ` | `service <name> <pathname> [ <argument> ]*    <option>    <option>    ...` |
| ---------- | ------------------------------------------------------------ |
|            |                                                              |

其中：

- name:服务名
- pathname:当前服务对应的程序位置
- option：当前服务设置的选项
- argument 可选参数