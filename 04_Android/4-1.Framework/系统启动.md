# Android系统启动的流程

![image-20231204170320731](D:\personal\CSLibrary\04_Android\imgs\image-20231204170320731.png)

Step1：启动电源及系统启动

当电源按下，引导芯片代码开始从预定义的地方（固化在ROM）开始执行。加载引导程序到RAM，然后执行。

Step2：引导程序

引导程序是在Android操作系统开始运行前的一个小程序。引导程序是运行的第一个程序，因此它是针对特定的主板与芯片的。设备制造商要么使用很受欢迎的引导程序比如redboot、uboot、qibootloader或者开发自己的引导程序，它不是Android操作系统的一部分。引导程序是OEM厂商或者运营商加锁和限制的地方。

引导程序分两个阶段执行：

第一个阶段，检测外部的RAM以及加载对第二阶段有用的程序；

第二个阶段，引导程序设置网络、内存等等。这些对于运行内核是必要的，为了达到特殊的目标，引导程序可以根据配置参数或者输入数据设置内核。

Android引导程序可以在\bootable\bootloader\legacy\usbloader找到。传统的加载器包含两个文件，需要在这里说明：

init.s初始化堆栈，清零BBS段，调用main.c的_main()函数；

main.c初始化硬件（闹钟、主板、键盘、控制台），创建Linux标签

Step3：内核

Android内核与桌面Linux内核的启动方式差不多。内核启动时，设置缓存、被保护存储器、计划列表，加载驱动。当内核完成系统设置，它首先在系统文件中寻找“init”文件，然后启动root进程或者系统的第一个进程

Step4：init进程

init进程时Linux系统中用户空间的第一个进程，进程号固定为1。Kernel启动后，在用户空间启动init进程，并调用init中的main() 方法执行init进程的职责。

Step5：启动Launcher App

# init进程分析

![image-20231205174832961](D:\personal\CSLibrary\04_Android\imgs\image-20231205174832961.png)

读图：

1. init进程启动zygote和servicemanager
2. zygote利用socket与system_server进行联系
3. system_server\servicemanager\app三者之间利用binder进行联系

init进程的操作：

1. 创建和挂载启动所需要的文件目录
2. 初始化和启动属性服务
3. 解析init.rc配置文件并启动Zygote进程

精炼源码分析（以后在更新的源码上再看一次）：

1. ueventd主要负责设备节点的创建、权限设定等一系列工作；watchdogd用于系统出问题时重启系统

2. 如果参数同时从命令行和DT传过来，DT的优先级总是大于命令行的

> 在 Android 中，"Device Tree"（设备树）通常是指 Android 操作系统的设备树机制。设备树是一种用于描述硬件设备和其连接关系的数据结构，它被广泛用于嵌入式系统中，包括 Android 设备。
>
> Android 设备树的主要目的是为了在 Linux 内核中动态描述和配置硬件设备。设备树通常以一种类似于 XML 的结构进行描述，其中包含了有关系统硬件、设备、中断、总线等信息的详细描述。
>
> 主要的 Android 设备树文件是 `dts`（设备树源）文件，它们编译成 `dtb`（设备树二进制）文件，然后由 Linux 内核加载并解释。设备树的使用允许 Android 操作系统在多种硬件平台上运行，而无需为每个平台定制和编译一个特定的内核。
>
> Android 设备树包括以下方面的信息：
>
> 1. **硬件组件：** 描述了处理器、内存、外设等硬件组件的信息。
> 2. **中断：** 描述了系统中各种中断的分配和连接。
> 3. **总线：** 描述了系统中使用的总线，如 I2C、SPI、PCI 等。
> 4. **设备：** 描述了连接到系统的各种设备，如传感器、摄像头、显示器等。
>
> 通过使用设备树，Android 能够更容易地适应各种硬件配置，使其更加灵活和可移植。

# init.rc解析

## 服务启动机制

1. system/core/init/init.c文件main函数中parse_config_file(init.rc)读取并解析init.rc文件内容。将service信息放置到system/core/init/init_parser.cpp的service_list中
2. system/core/init/init.c文件main函数继续执行restart_servie_if_needed(…) -> service_start(…) -> Execve(…)建立service进程；

为了让大伙看得更明白，上个图先《总体启动框架图》： ![img](https://raw.githubusercontent.com/mazhidong/Picture/master/Blog/2019-01-18/init.png)

## init.rc 简介

目前Linux有很多通讯机制可以在用户空间和内核空间之间交互，例如设备驱动文件（位于/dev目录中）、内存文件（/proc、/sys目录等）。了解Linux的同学都应该知道Linux的重要特征之一就是一切都是以文件的形式存在的，例如，一个设备通常与一个或多个设备文件对应。这些与内核空间交互的文件都在用户空间，所以在Linux内核装载完，需要首先建立这些文件所在的目录。而完成这些工作的程序就是本文要介绍的init。Init是一个命令行程序。其主要工作之一就是建立这些与内核空间交互的文件所在的目录。当Linux内核加载完后，要做的第一件事就是调用init程序，也就是说，init是用户空间执行的第一个程序。

尽管init完成的工作不算很多，不过代码还是非常复杂的。***Init程序并不是由一个源代码文件组成的\***，而是由一组源代码文件的目标文件链接而成的。这些文件位于如下的目录。

需要明白的是，这些init.rc只是语法文件，并不是程序，真正的入口则是上面提到的system/core/init/init.c 因为init.c文件比较大，在文章的第二部分我会简要的通过main函数分析init启动流程；

init.rc有两个，分别位于：
./system/core/rootdir/init.rc
./bootable/recovery/etc/init.rc
从目录上大致可以猜测，这两个init.rc使用场景不一样，一个是刷机用到的，也就是进入recorvery模式，一个是正常启动用到的；我们这里重点分析的是上面那个，也是init.c关联的那个；