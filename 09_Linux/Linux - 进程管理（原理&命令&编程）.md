

# 进程通信 IPC

Linux系统中进程通信的机制继承自Unix，后经贝尔实验室与BSD对进程间通讯手段的改进与扩充，以及POSIX标准对Unix标准的统一，发展出如今Linux系统中使用的进程通信(IPC)机制，即包含管道通信、信号量、消息队列、共享内存以及socket通信等的诸多通信机制。

## 管道

管道是一种最基本的进程通信机制，其实质是由内核管理的一个缓冲区，可以形象地认为管道的两端连接着两个要进行通信的进程。其中一个进程进行信息输出，将数据写入管道；另一个进程进行信息输入，从管道中读取信息。

管道的逻辑结构如图所示：

![image-20230411181858341](E:\personal\CSLibrary\09_Linux\imgs\image-20230411181858341.png)

管道分为匿名管道(pipe)和命名管道(named pipe)。

在进程中创建的管道是匿名管道，进程退出后管道会被销毁，匿名管道只能用于有亲缘关系的进程间通信。

命名管道被具象化为一个文件，在进程中可使用操作文件的方式向内存中写入或从内存中读出数据，命名管道与进程的联系较弱。相当于一个读写内存的接口，进程退出后，命名管道依然存在。

### 匿名管道

#### pipe()

匿名管道利用fork机制建立联系，刚创建出的管道，读写两端都连接在同一个进程上，当进程中调用fork()创建子进程后，父子进程共享文件描述符，因此子进埕拥有与父进程相同的管道。pipe()创建管后读端对应的文件描述符为fd[0]，写端对应的文件描述符为fd[1]。

- 管道采用半双工通信方式。只能进行单向数据传递，为严谨起见，应使用close()函数关闭除通信端口之外的端口。
- 管道只能进行半双工通信。若要实现同时双向通信，需要为通信的进程创建两个管道
- 有指向管道读端的文件描述符打开时，向管道中与入数据才有意义。
- 若所有指向管道与端的文件描述符都被关闭后仍有进程从管道的读端读取数据，那么管道中剩余的数据都被读取后，再次read会返回0。
- 若有指向管道写端的文件描述符未关闭，而管道写端的进程也没有向管道中写入数据，那么当进程从管道中读取数据，且管道中剩余的数据都被读取时，再次read会阻塞，直到与端向管道写入数据，阻塞才会解除。
- 若有指向管道读端的文件描述符没关闭，但读端进程没有从管道中读取数庭，写端进程持续向管道中写入数据，那么管道缓存区写满时冉次write会阻塞，直到读端将数据读出，阻塞才会解除。
- 管道中的数据以字节流的形式传输，这要求管道两端的进程事先约定好数据的格式。

#### popen()/pclose()

```
FILE*popen(const char *command，const char *type);
int pclose(FILE *stream）；
```

popen()函数的功能是：调用pipe()函数创建管道，调用fork()函数创建子进程，之后在子进程中通过execve()函数调用shell命令执行相应功能。若整个流程都成功执行，则返回一个I/O文件指针；若pipe()或fork()函数调用失败，或因无法分配内存等原因造成popen()函数调用失败，该函数将会返回NULL。

![image-20230411183322659](E:\personal\CSLibrary\09_Linux\imgs\image-20230411183322659.png)

pclose()函数的功能是关闭由popen()打开的I/O流，并通过调用wait()函数等待子进程命令执行结束，返回shell的终止状态，防止产生僵尸进程。与文件操作函数fopen()类似，popen()调用之后务必要使用pclose()函数关闭打开的文件I/O指针，若pclose()函数调用失攸，则返回-1。

### 命名管道

命名管道又名FIFO(first in first out)，它与匿名管道的不同之处在于：命名管道与系统中的一个路径名关朕，以文件的形式存在于文件系统中。如此，系统中的不同进程可以通过FIFO的路径名访问FIFO文件，实现彼此间的通信。

#### mkfifo()

mkfifo命令的参数一般为文件名，其常用参数为 -m，用于指定所创建文件的权限。

在程序中创建FIFO文件的函数与mkfifo同名，mkfifo()的头文件为sys/type.h与sys/stat.h，其函数声明如下：

```
int mkfifo(const char *pathname，mode_t_mode);
```

## 消息队列

消息队列的实质是一个存放消息的表，该链表由内核维护；消息队列中的每个消息可以视为一条记录，消息包括一个长整型的类型字段和需要传递的数据。消息队列由消息队列标识符(queue ID）标识，对消息队列有读权限的进程可以从队列中读取消息，对消息队列有写权限的进程可以照规则，向其中添加消息。

特点：

- 与管道相比。消息队列的通信方式更为灵活
- 提供有格式的字节流，无需通信双方额外约定数传输格式
- 将消息设定为不同类型，并分配了不同的优先级
- 新添加的消息总是在队尾，但接收消息的进程可以读取队列中间的数据
- 降低了读与进程间的耦合强度

与FIFO类似，消息队列可以实现无亲缘关系进程间的通信，且独立于通信双方的进程之外，若没有删除内核中的消息队列，即便所有使用消息队列的进程都已终止，消息队列仍存在于内核中，直到内核重新启动、管理命令被执行或调用系统接囗删除消息队列时，消息队列才会真正被销毁。

注意：

- 系统中的最大消息队列数与系统中最大消息数都有一定限制，分别由宏MSGMNI和F宏MSGTOL定义
- 消息队列的每个消息中所含数据块的长度以及队列中所含数据块的总长度也有限制，分别由宏MSGMAX和宏MSGMNB定义。

使用消息队列实现进程间通信的步骤如下：

- 创建消息队列 msgget()
- 发送消息到消息队列 msgnd()
- 从消息队列中读取数据 msgrcv()
- 删除消息队列 msgctl()

**键值与标识符:**

对多个进程来说。要通过消息队列机制实现进程间通信，必须能与相同消息队列进行关朕，键值(key)就是实现进程与消息队列关联的关腱。当在进程中调用msgget()函数创建消息队列时，传入的key值会被保存到内核中，与msgget()函数创建的消息队列一一对应：若进程中调用msgget()函数获取已存在的消息队列，只需向msgget()函数中传入键值。就能获取到内核中与键值对应的消息队列。也就是说，键值是消息队列在内存级别的唯一标识。

对单个进程来说，可能需要实现与多个进程间的通信，因此会与多个消息队列关朕，当多次调用msgget()函数与多个消息队列进行关联时，每个msgget()函数都会返回一个非负整数，这个非负整数就是进程对消息队列的标识。标识符是消息队列在进程级别的唯一标识。

## 信号量

Linux系统采用多道裎序设计技木，允许多个进程同时在内核中运行，但同一个系统中的多个进程之间，可能因为进程合作或资源共享，产生制约关系。



制约关系分为直接制约关系和间接制约关系：

- 需要进程间协调合作导致的制约关系。称为直接相互制约关系。
- 因资源共享导致的制约关系。称为间接相互制约关系．

直接相互制约的进程间有同步关系，间接相互制约的进程间有互斥关系，同步与互斥存在的根源是系统中存在临界资源(Critical Resource)



计算机中的硬件资源（如内存、打印机、磁盘）以及软件资源（如共享代码段．变量等）都是临界资源，为了避免多进程的并发执行造成的不一致性，临界资源在同时刻只允许有限个进程对其进行访问或修改。

计算机中的多个讲程必须互斥地访问系统中的临界资源，用于访问临界资源的代码称为临界区(Critical Section），临界区也属于临界资源，若能保证进程间互斥地进入自己的临界区，就能实现进程对临界资源的互斥访问。



信号量(Semaphore)是专门用于解决进程同步与互斥问题的一种通信机制，它与信号无关，也不同于管道、FIFO以及消息队列。一般不用来传输数据，信号量包括一个被称为信号量的表示资源数量的非负整型变量、修改信号量的原子操作P和V，以及该信号量下等待资源的进程队列。



在Linux系统中，不同的进程通过获取同一个信号量键值进行通信，实现进程间对资源的互斥访问。使用信号量进行通信时，通常需要以下步骤：

- 创建信号量/信号量集，或获取系统中已有的信号量/信号量集；semget()
- 初始化信号量。早期信号量通常被初始为1,但有些进程一次需要多个同类的临界资源，或多个不同类且不唯一的临界资源，因此可能需要初始化的不是信号量，而是一个信号量集；semctl()
- 信号量的P、V操作，根据进程请求，修改信号量的数量。执行P操作会使信号量 -1，执行V操作会使信号量 +1；semop()
- 从系统中删除不需要的信号量；semctl()

## 共享内存

共亨内存允许两个或多个进程访问给定的同一块存储区域。已知当一个进程被启动时，系统会为其创建一个0-4G的虚拟内存空间，根据虚拟地址与物理地址之间的映射关系，进程可以通过操作虚拟地址，实现对物理页面的操作。

一般情况下。每个进程的虚拟地址会与不同的物理地址进行映射．但是当使用共亨内存进行通信时，系统会将同一段物理内存映射给不同的进程。两个进程的虚拟地址空间与共享内存之间的映射关系如图：

![image-20230412173149840](E:\personal\CSLibrary\09_Linux\imgs\image-20230412173149840.png)

- 创建一块新的共享内存，或打开一块已经存在的共享内存；shmget()
- 进行地址映射，将共享内存映射到进程虚拟地址空间中；shmat()
- 解除物理内存与进程虚拟地址空间的映射关系；shmdt()
- 对已存在的共享内存进行操作；shmctl()

# 进程

## 标识符

- 进程标识符，简称pid，是进程的唯一标识
- 父进程标识符，简称ppid，标识该进程的父进程，即创建进程的进程所对应的pid
- 用户标识符，简称uid，标识创建该进程的用户。此外euid标识有效用户的标识符
- 组标识符：简称gid，标识创建进程用户的所属组，Euid对应的组标识符即为egid

## 进程状态

![image-20230404110918887](E:\personal\CSLibrary\09_Linux\imgs\image-20230404110918887.png)

通常进程的状态被划分为五种：初始态、就绪态、运行态、睡眠态和中止态。初始态一般不进行讨论，因为当初始化完成后，进程会立刻转化为就绪态。

- 就绪态：处于就绪态（Ready）的进程，所需的其它资源已分配到位，此时只等待cpu，当可以使用cpu时，进程会立刻变为运行态。
- 运行态：进程处于运行态（Execting）时会占用cpu，处于此状态的进程的数目必定小于等于处理器的数目，即每个cpu上至多只能运行一个进程
- 睡眠态：处于睡眠态（Sleeping）的进程会因某种原因暂时不能占有cpu。睡眠态分为不可中断的睡眠和可中断的睡眠。
- 终止态：处于终止态的进程已运行完毕，此时进程不会被调度，也不会再占用CPU。



## PCB

每个进程的PCB中都有一个指向页表的指针、进程、页表与内存之间的映射关系如图所示

![image-20230404161621762](E:\personal\CSLibrary\09_Linux\imgs\image-20230404161621762.png)

进程组由用户启动的进程创建，用户启动的进程是进程组中的领导进程（process group leader），进程组中领导进程的pid亦是识别进程组的进程组id，即pgid。



## 进程组与会话

会话（session）是进程组的集合，会话中的每个进程组称为一个工作（job）

会话由其中的进程创建，创建会话的进程称为会话的领导进程（session leader），会话领导进程的pid也是标识会话的会话id，即sid

一个会话中一般有一个进程组工作在前台，使用终端，其余进程组工作在后台（在终端执行命令时，在命令之后添加“&”则将命令启动的进程放在后台执行）。会话的意义在于可在同一个终端执行多个进程组。



## 进程控制

![image-20230404162131621](E:\personal\CSLibrary\09_Linux\imgs\image-20230404162131621.png)

fork()

exec函数族

exit()/_exit()

exit()和\_exit()都是用来终止进程的，但它们所做的操作有些许差别：当程序执行到 \_exit()函数时，系统会无条件地停止剩下操作，终止进程，并清除进程所用内存空间以及进程在内核中的各种数据结构；exit()函数对\_exit()进行了包装，在执行退出前还有若干道工序，最重要的就是它会在调用_exit()之前先检查文件的打开情况，将缓冲区中的内容写回文件。相对而言，exit()函数相比\_exit()函数更为安全。



孤儿进程：父进程在进程退出前退出，子进程变为孤儿进程。

僵尸进程：当进程调用了exit()函数后，该进程并不是马上消失，而是留下一个称为僵尸进程（Zombie）的数据结构。僵尸进程是Linux系统中的另一种特殊进程，它几乎放弃进程退出前占用的所有内存，既没有可执行代码，也不能被调度，只在进程列表中保留一个位置，记载进程的退出状态等信息，供父进程收集。



## 进程同步

wait()

处于僵尸态的进程不能再次被运行．但是却会占用一定的内存空间，并占据进程编号，当系统中僵尸进程较多时，将会消耗系统的大部分内存，新的进程可能因内存不足或无法获取pid而无法创建，因此应尽量免僵尸进程的产生。

在父进程中通过wait()和waitpid()函数可以有效防止僵尸进程的产生，对于内存中已经存在的僵尸进程，则可通过杀死其父进程的方法解决。

当僵尸进程的父进程被终止后，僵尸进程将作为孤儿进程被init进程接收，init进程会不断调用wait()函数获取子进程状态。对已处于僵尸态的进程进行处理。

孤儿程水远不会成为僵尸进程。



## 进程管理命令

### ps

Process Status 缩写，在命令行输入ps后回车就能查看当前系统中正在运行的进程

| 选项 | 说明                                               |
| ---- | -------------------------------------------------- |
| a    | 显示当前终端机下的所有进程，包括其它用户启动的进程 |
| u    | 以用户的形式，显示系统中的进程                     |
| x    | 忽视终端机，显示所有进程                           |
| e    | 显示每个进程使用的环境变量                         |
| r    | 只列出当前终端机中正在执行的进程                   |

### top

ps命令执行后，会显示执行命令那一刻系统中进程的相关信息，若想信息动态地显示，可以使用top命令。

top默认的更新间隔为3s。

### pstree

以树状图形式显示系统中的进程，可以直接观察到进程之间的派生关系

### pgrep

根据进程名从进程队列中查找进程，查找成功后默认显示进程的pid

### nice

设置Linux系统中进程的nice值

### bg

将进程放入后台运行，使前台可以执行其它任务

### fg

将后台的进程调往前台

### jobs

查看Linux系统中的作业列表及作业状态，进程中的作业也有编号，编号从1开始。Linux系统中作业从用户角度进行编号，进程从系统管理员的角度进行编号。

当选项和参数缺省时，默认显示作业编号、作业状态和启动作业的命令。

### kill

终止正在运行的进程，工作原理是发送某个信号到指定进程，以终止该进程。

# 线程

## 线程概述

与进程不同。线程(Thread)是系统调度分派的最小单位，与进程相比，线程没有独立的地址空间。多个线程共享一段地址空间。因此线程消耗更少的内存资源，线程间的通信也更为方便，有时线程也被称为轻量级进程(Light Weight Process，LWP)

Linux系统中的线程借助进程机制实现，线程与进程联系密切：

进程可以蜕变成线程，当在一个进程中创建一个线程时，原有的进程就会变成线程，两个线裎共用一段地址空间，

线程又被称为轻量级讲程。线程的TCB(Thread Control Block，线程控制块）与进程的PCB相同，因此也可以将TCB视为PCB；

对内核而言，线程与进程没有区别，cpu会为个线程与进程分配时间片，并通过PCB来调度不同的线程和进程。

![image-20230412180030852](E:\personal\CSLibrary\09_Linux\imgs\image-20230412180030852.png)

进程与线程

- 进程组成：线程集+资源集（地址空间、打开的文件描述符、用户信息等）
- 线程组成：程序、数据、TCB以及少量必不可少的用于保证线程独立运行的资源、程序计数器、栈空间、寄存器
- 优点：同一个进程地址空间的多个线程共享虚拟地址空间，进而共享相同的页目录、页表和物理页面，因此线程间的许多数据是共享的，线程不必通过类似进程通信使用的管道、信号量等机制，便能进行通信
- 缺点：因为多个线程共享一段地址空间，当多个线程同时需要对其中的数据进行访问时，可能会因竞争导致读写错误，因此，正如控制多个进程对共享资的访问一样，系统同样也应实现对线程间的共享数据的同步。



### 线程操作

#### pthread_create()

进程拥有独立的地址空间，当使用fork()函数创建出新进程后，若其中一个讲程要对fork()之前的数据进行修改，进程中会依据“写时复制”原则，,先复制一分该数据到子进程的地址空间，再修改数据，因此即便是全局变量。在进程间也是平共享的。

但由于线程间共享地址空间，因此在一个线程中对全局区的数据进行修改，其它线程中访问到的也是修改后的数据。

#### pthread_exit()

return和exit()也有退出功能，但retum用于退出函数，exit()用于退出进程。

#### pthread_cancel()

线程机制中厍用于终止线程的函数为pthread_cancel，该函数对应线程机制中的kill()函数，pthread_cancel()函数可向指定线程发送信号CANCEL，使一个线程强行杀死另外一个线程。

#### pthread_join()

在进程中，父进程退出，子进程仍可继续执行；但在线程中，作为程序入口的主线程退出，属于同一进程中的所有线程都会退出。

为避免主线程提前退出对其它线程造成影响，可以使用pthread_join()函数将主线程挂起。

#### pthread_detach()

在线程终止后，其它线程调甲pthread_join()数获取该线程的终止状态前，该线程会一直保持终止状态，这种状态类似讲程中的僵尸态。为避兔处于终止状态的线程占用内存，线程机制中提供了pthread_detach()函数，可在线程被创建后设置线程分离，被分离的线程在执行结束后将会自动释放，不再等待其它线程回收

## 线程属性

### 线程同步

### 互斥锁

使用互斥锁实现线程同步时，系统会为共享资源添加一个称为互斥锁的标记，防止多个线程在同一时刻访问相同的共用资源。

### 条件变量

使用互斥锁实现线程同步时，系统会为共享资源添加一个称为互斥锁的标记，防止多个线程在同一时刻访问相同的共用资源。

### 信号量

使用信号量实现线程同步时，线程在访问共享资源时会根据操作类型执行P/V操作：若有线程申请访问共享资源，系统会执行P操作使共享资源计数减一；若有线程释放共亨资源，系统会执行V操作共享资源计数加一。